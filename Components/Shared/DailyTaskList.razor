@using Mantis.Domain.Renewals.ViewModels
@using Mantis.Domain.Renewals.Services
@using Mantis.Domain.Shared
@using Microsoft.FluentUI.AspNetCore.Components
@inject TaskService TaskService
@rendermode InteractiveServer

<div class="sectiontitletab">Daily Tasks</div>
<div class="dailytask-box">
    <FluentTextField Id="newTaskInput" Placeholder="Add a new task..." @bind-Value="newTaskName" @onkeypress="OnKeyPress">
        <FluentIcon Value="@(new Icons.Regular.Size16.Add())" Slot="end" Color="Color.Neutral" @onclick="async () => await AddNewTaskWithDelay()" />
    </FluentTextField>
    @if (DailyTasks == null)
    {
        <p>Loading tasks...</p>
    }
    else if (!DailyTasks.Any())
    {
        <p>No tasks available.</p>
    }
    else
    {
        <FluentGrid Justify="JustifyContent.FlexStart" Spacing="3">
            <FluentGridItem xs="12" sm="6">
                <FluentSortableList Id="sortableList" Items="DailyTasks" OnUpdate="@SortList">
                    <ItemTemplate>
                        <div style="display: flex; align-items: center;" class="@GetTaskCssClass(context)">
                            <FluentCheckbox @bind-Checked="context.Completed" @onchange="async (e) => await CompleteTask(context)" />
                            <span style="margin-left: 10px;">@context.TaskName</span>
                        </div>
                    </ItemTemplate>
                </FluentSortableList>
            </FluentGridItem>
        </FluentGrid>
    }
</div>

@code {
    [Parameter]
    public List<DailyTask> DailyTasks { get; set; } = new List<DailyTask>();

    private string newTaskName = "";
   
    protected override void OnParametersSet()
    {
        if (DailyTasks != null)
        {
            // Ensure completed tasks are always at the bottom
            DailyTasks = DailyTasks
                .OrderBy(t => t.Completed)
                .ToList();
        }
    }

    private void SortList(FluentSortableListEventArgs args)
    {
        if (args is null || args.OldIndex == args.NewIndex)
        {
            return;
        }

        var itemToMove = DailyTasks[args.OldIndex];
        DailyTasks.RemoveAt(args.OldIndex);

        if (args.NewIndex < DailyTasks.Count)
        {
            DailyTasks.Insert(args.NewIndex, itemToMove);
        }
        else
        {
            DailyTasks.Add(itemToMove);
        }

        // Re-sort tasks after manual sorting
        DailyTasks = DailyTasks
            .OrderBy(t => t.Completed)
            .ToList();

        StateHasChanged(); // Ensure the UI updates correctly
    }
    private async Task OnKeyPress(KeyboardEventArgs e)
    {
        Console.WriteLine("KEY::::::::::::::::::::" + e.Key);
        if (e.Key == "Enter")
        {
            await Task.Delay(10);
            await AddNewTask();
        }
    }
    private async Task AddNewTaskWithDelay()
    {
        Console.WriteLine("delay");
        StateHasChanged();
        await Task.Delay(50);
        await AddNewTask();
    }
    private async Task AddNewTask()
    {
        if (!string.IsNullOrWhiteSpace(newTaskName))
        {
            var newTask = new DailyTask { TaskName = newTaskName, Completed = false };
            await TaskService.AddNewDailyTaskAsync(newTask);

            DailyTasks.Add(newTask);

            // Re-sort tasks after adding a new one
            DailyTasks = DailyTasks
                .OrderBy(t => t.Completed)
                .ToList();

            newTaskName = "";
        }
    }
    private async Task CompleteTask(DailyTask task)
    {
        task.Completed = true;
        await TaskService.UpdateDailyTaskAsync(task);

        // Re-sort tasks after completing one
        DailyTasks = DailyTasks
            .OrderBy(t => t.Completed)
            .ToList();

        // Force the component to re-render after updating the list
        StateHasChanged();
    }
    private string GetTaskCssClass(DailyTask task)
    {
        return task.Completed ? "completed-task" : string.Empty;
    }
}